# Question 91: Decode Ways

## Problem Description
A message containing letters from `A-Z` can be encoded into numbers using the mapping:

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

To decode an encoded message, determine the total number of ways to decode it.

## Step-by-Step Explanation

1. **Handle Edge Cases:**
   - If the string is null or empty, return 0.
   - If the first character is '0', the message is invalid, so return 0.

2. **Dynamic Programming Approach:**
   - Use two variables `prev1` and `prev2` to store the number of ways to decode the previous one and two characters, respectively.
   - Initialize `prev2` to 1 (base case) and `prev1` based on whether the first character is '0'.

3. **Iterate Through the String:**
   - For each character in the string, calculate the number of ways to decode the substring ending at that character:
     - If the current character is not '0', add `prev1` to the current count.
     - If the last two characters form a valid number (10 to 26), add `prev2` to the current count.

4. **Update Variables:**
   - Update `prev2` to `prev1` and `prev1` to the current count.

5. **Return the Result:**
   - The result is stored in `prev1` after processing the entire string.

## Code Implementation

```java
class Solution_Q91 {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) return 0;
        int n = s.length();
        int prev2 = 1; 
        int prev1 = s.charAt(0) != '0' ? 1 : 0; 
        for (int i = 2; i <= n; i++) {
            int curr = 0;
            char c1 = s.charAt(i - 1);
            char c0 = s.charAt(i - 2);

            if (c1 != '0') curr += prev1;

            int two = (c0 - '0') * 10 + (c1 - '0');
            if (two >= 10 && two <= 26) curr += prev2;

            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```